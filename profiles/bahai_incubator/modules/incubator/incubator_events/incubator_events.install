<?php
// $Id$

/**
 * @file
 *
 */

function incubator_events_install() {
  variable_set('fullcalendar_path', 'profiles/bahai_incubator/libraries/fullcalendar/fullcalendar');
}

function incubator_events_enable() {
  $t = get_t();

  // CREATE Activity Group VOCABULARY
  if (!$vocabulary = taxonomy_vocabulary_machine_name_load('activity_group')) {
    $description = $t('Target search terms for public events.');
    $help = $t('Choose one or more groups if appropriate.');
    $vocabulary = (object) array(
      'name' => $t('Activity Group'),
      'description' => $description,
      'machine_name' => 'activity_group',
      'help' => $help,
    );
    taxonomy_vocabulary_save($vocabulary);
    // set pathauto definition
    variable_set('pathauto_taxonomy_term_activity_group_pattern', 'events/upcoming/[term:name]');

    // create field_main_image
    // attach field_main_image to Activity Type
    _incubator_attach_field('field_main_image', 'activity_group', 'taxonomy_term');

    $vocabulary = taxonomy_vocabulary_machine_name_load('activity_group');
    foreach (_incubator_taxonomy_terms('activity_group') as $name) {
      $term = (object) array(
        'vid' => $vocabulary->vid,
        'name' => $name,
      );
      taxonomy_term_save($term);
    }
  }

  // CREATE Event content type
  $type = array(
    'type' => 'event',
    'name' => $t('Event', array(), array('#context' => 'Node type name')),
    'description' => $t('Use an <em>Event</em> for single or recurring community events.')
  );
  $pathauto_prefix = $t('events/', array(), array('#context' => 'Web search friendly URL - no special characters'));
  if (_incubator_create_nodetype($type, $pathauto_prefix, 2, FALSE)) {
    _incubator_attach_field('field_main_image', 'event');
    _incubator_attach_field('field_tags', 'event');
    _incubator_attach_field('field_localities', 'event');
    _incubator_attach_field('field_activity_type', 'event');
    _incubator_attach_field('field_activity_group', 'event');
    _incubator_attach_field('field_event_info', 'event');
    _incubator_attach_field('field_event_date', 'event');
    // add location
    _incubator_set_location('event', array('multiple' => array('min' => 1, 'max' => 1, 'add' => 1), 'form' => array('weight' => -20), 'display' => array('weight' => -9)));
    variable_set('location_chooser_targets', array_merge(variable_get('location_chooser_targets', array()), array('event')));
    variable_set("pathauto_node_{$type['type']}_pattern", variable_get("pathauto_node_{$type['type']}_pattern", '') . '-10[node:nid]');
  }

  // create Host role
  _incubator_create_role('host', 'event');

  // Fix date formats for views
  foreach (array('time_only' => 'g:ia', 'date_only' => 'D, M j') as $name => $def) {
    if (!db_query('SELECT COUNT(*) FROM {date_format_type} WHERE type LIKE ?', array($name))->fetchField()) {
      db_insert('date_format_type')->fields(array('type' => $name, 'title' => ucfirst(str_replace('_', ' ', $name)), 'locked' => 0))->execute();
    }
    if (!db_query('SELECT COUNT(*) FROM {date_formats} WHERE format = ?', array($def))->fetchField()) {
      db_insert('date_formats')->fields(array('format' => $def, 'type' => 'custom', 'locked' => 0))->execute();
    }
    variable_set("date_format_$name", $def);
  }

  // Permissions for dates
  foreach(array('editor', 'administrator') as $role) {
    if ($r = user_role_load_by_name($role)) { // intentional assignment of $r
      user_role_grant_permissions($r->rid, array('view date repeats'));
    }
  }

  variable_set('incubator_events_rebuild_menus', TRUE);

}

function incubator_events_disable() {
  module_load_install('incubator');
  _incubator_delete_nodetype('event');
  $role = user_role_load_by_name('host');
  user_role_change_permissions($role->rid, array());
}

function incubator_events_uninstall() {
  user_role_delete('host');
}

function incubator_events_incubator_default_blocks() {
  return array(
    'events:all' => array(
      'module' => 'views',
      'delta' => 'upcoming_events-block',
      'weight' => 0,
      'visibility' => 0,
      'pages' => "events/upcoming\nevents/upcoming/*\nevents/calendar\nevents/calendar/*\nactivities/*\nlocal/*"
    ),
    'events:by-term' => array(
      'module' => 'views',
      'delta' => 'upcoming_events-block_1',
      'weight' => 0,
      'visibility' => 1,
      'pages' => "activities/*\nlocal/*",
    ),
  );
}

/**
 * Adding date formats for views
 */
function incubator_events_update_7101() {
  // Fix date formats for views
  foreach (array('time_only' => 'g:ia', 'date_only' => 'D, M j') as $name => $def) {
    if (!db_query('SELECT COUNT(*) FROM {date_format_type} WHERE type LIKE ?', array($name))->fetchField()) {
      db_insert('date_format_type')->fields(array('type' => $name, 'title' => ucfirst(str_replace('_', ' ', $name)), 'locked' => 0))->execute();
    }
    if (!db_query('SELECT COUNT(*) FROM {date_formats} WHERE format = ?', array($def))->fetchField()) {
      db_insert('date_formats')->fields(array('format' => $def, 'type' => 'custom', 'locked' => 0))->execute();
    }
    variable_set("date_format_$name", $def);
  }
}

/**
 * Update events blocks configurations
 */
function incubator_events_update_7102() {
  _incubator_enable_blocks(incubator_events_incubator_default_blocks());
}

/**
 * Enable views_date_format_sql module, and adjust the database accordingly.
 * Untested in pgsql.  Please, please backup first.
 */
function incubator_events_update_7103() {
  module_enable(array('views_date_format_sql'));
  switch (db_driver()) {
    case 'mysql':
    case 'mysqli':
      $expression = 'UNIX_TIMESTAMP(';
      break;
    case 'pgsql':
      $expression = 'EXTRACT(EPOCH FROM ';
      break;
    default:
      drupal_set_message('Update could not complete, owing to an unsupported database type.', 'error');
      return;
  }
  foreach (array('field_data_field_event_date', 'field_revision_field_event_date') as $table) {
    db_add_field($table, 'new_field_event_date_value', array('type' => 'int', 'default' => NULL));
    db_add_field($table, 'new_field_event_date_value2', array('type' => 'int', 'default' => NULL));
    db_update($table)
      ->expression('new_field_event_date_value', "{$expression}field_event_date_value)")
      ->expression('new_field_event_date_value2', "{$expression}field_event_date_value2)")
      ->execute();
    db_drop_field($table, 'field_event_date_value');
    db_drop_field($table, 'field_event_date_value2');
    db_change_field($table, 'new_field_event_date_value', 'field_event_date_value', array('type' => 'int', 'default' => NULL));
    db_change_field($table, 'new_field_event_date_value2', 'field_event_date_value2', array('type' => 'int', 'default' => NULL));
  }
  db_update('field_config')->fields(array('type' => 'datestamp'))->condition('field_name', 'field_event_date')->execute();
  drupal_flush_all_caches();
}

/**
 * Hide label on field_event_info, since inline makes page wrapping problematic
 */
function incubator_events_update_7104() {
  if ($instance = field_info_instance('node', 'field_event_info', 'event')) { // intentional assignment of $instance
    $instance['display']['default']['label'] = 'hidden';
    field_update_instance($instance);
  }
}

/**
 * Update the fullcalendar path, block pages, and views
 */
function incubator_events_update_7105() {
  variable_set('fullcalendar_path', 'profiles/bahai_incubator/libraries/fullcalendar/fullcalendar');
  db_update('block')->expression('pages', "REPLACE(pages, 'events/upcoming/*', 'events/upcoming/*\nevents/calendar\nevents/calendar/*')")->execute();
  $view = views_get_view('upcoming_events');
  if ($view->type == t('Overridden')) {
    $view->delete();
    ctools_include('object-cache');
    ctools_object_cache_clear('view', $view->name);
  }
  cache_clear_all('ctools_export:views_view:upcoming_events', 'cache_views');
  if ($link = db_query('SELECT * FROM {menu_links} WHERE router_path = :path', array(':path' => 'events/upcoming'))->fetchAssoc()) {
    $link['hidden'] = 1;
    variable_set('incubator_events_views_upcoming_title', $link['link_title']);
    $link['options'] = unserialize($link['options']);
    $link['customized'] = 1;
    $weight = $link['weight'];
    menu_link_save($link);
  }
  menu_rebuild();
}

/**
 * Rebuild the menu items for event list and calendar
 */
function incubator_events_update_7106() {
  variable_set('incubator_events_rebuild_menus', TRUE);
}

/**
 * Change field label from "event info" to "time and place"
 */
function incubator_events_update_7107() {
  if ($instance = field_info_instance('node', 'field_event_info', 'event')) { // intentional assignment of $instance
    $t = get_t();
    $instance['label'] = $t('Time and place');
    field_update_instance($instance);
  }
}

/**
 * Fix 24-hour time entry for date field
 */
function incubator_events_update_7108() {
  if ($instance = field_info_instance('node', 'field_event_date', 'event')) { // intentional assignment of $instance
    $instance['widget']['settings']['input_format'] = 'm/d/Y - g:i:sa';
    field_update_instance($instance);
  }
}

/**
 * Hide "submitted by" for events
 */
function incubator_events_update_7109() {
  variable_set("node_submitted_event", FALSE);
}

/**
 * Refactor activities view concept
 */
function incubator_events_update_7110() {
  if (module_exists('path') && module_exists('incubator_events')) {
    // Revert the upcoming_events view. Must be done because of errors with updated modules.
    $view = views_get_view('upcoming_events');
    $view->delete();
    // Change the path for activity_group terms
    variable_set('pathauto_taxonomy_term_activity_group_pattern', 'events/upcoming/[term:name]');
    // Redirect the activities view to events, until they turn that view on
    _incubator_redirect('activities', 'events');
    // Change all the term pages over to the upcoming_events view
    $terms = _incubator_events_get_activities_terms();
    $terms = entity_load('taxonomy_term', array_keys($terms));
    foreach ($terms as $tid => $term) {
      $aliases = db_query('SELECT pid, alias FROM {url_alias} WHERE source = ?', array("taxonomy/term/$tid"))->fetchAllKeyed();
      foreach ($aliases as $pid => $path) {
        db_delete('url_alias')->condition('pid', $pid)->execute();
        _incubator_redirect($path, "taxonomy/term/$tid");
      }
      _incubator_redirect("events/upcoming/$tid", "taxonomy/term/$tid");
      if (module_load_include('inc', 'pathauto')) {
        $new_path = pathauto_create_alias('taxonomy_term', 'update', "taxonomy/term/$tid", array('term' => $term), 'activity_group');
      }
    }
    // Change the path pattern for event nodes, and migrate them over to /events
    if (variable_get('pathauto_node_event_pattern', '') == 'event/[node:title]-10[node:nid]') {
      $nodes = db_query('SELECT * FROM {node} WHERE type = ?', array('event'))->fetchAllAssoc('nid');
      variable_set('pathauto_node_event_pattern', 'events/[node:title]-10[node:nid]');
      foreach ($nodes as $nid => $node) {
        $aliases = db_query('SELECT pid, alias FROM {url_alias} WHERE source = ?', array("node/$nid"))->fetchAllKeyed();
        foreach ($aliases as $pid => $path) {
          db_delete('url_alias')->condition('pid', $pid)->execute();
          _incubator_redirect($path, "node/$nid");
        }
        if (module_load_include('inc', 'pathauto')) {
          $new_path = pathauto_create_alias('node', 'update', "node/$nid", array('node' => $node), 'event');
        }
      }
    }
  }
}
